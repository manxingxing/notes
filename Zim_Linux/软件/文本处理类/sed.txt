Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2012-04-28T01:04:17+08:00

====== sed ======
Created 星期六 28 四月 2012


	sed [-nefr] [**动作**] [输入文件 | 标准输入]

-n 	不显示输入的字符流
-r	使用增强的正则表达式
-i	in-place editing。直接对原文本流进行修改！ 危险动作。注意和 下面操作命令里的 i 是不同的，这儿改变sed工作的方式，后面讲的是执行的动作

* 执行的动作，必须放在 **单引号** 中

==== 两种模式 ====

=== 把 要进行的操作放在命令行中 ===
-e '操作'

=== 把 要进行的操作放在sed文本中 ===
-f filename

===== 动作 =====

==== 选择要操作的行 ====

	3
	1,2
	2,$
	/regex/  能匹配该正则表达式的行
	/regex/, /regex/   两个正则表达式匹配行之间的内容
	2, /regex/ 	从第二行到正则表达式匹配为止


=== 数字范围 ===


=== 正则表达式匹配 ===
当带有 -r 参数调用 sed时，使用增强的正则表达式语法，默认使用基本正则表达式特性

==== 操作命令 ====

=== 打印输出: p ===
* 经常配合 -n 选项

=== 整行删除:  d ===

nl /etc/passwd |sed -e '2,5d'

=== 替换 ===

== 整行替换： c ==
把选中的**行**用指定的字符串替代

== 部分替换 : s ==
经常配合正则表达式进行替换

s/regex/replacment///modifier//

**分割符**：默认是 /，也可使用 _ | 等分割符，只要它们是成对出现的就成
**修饰符**： g, i, x, 

**当一行内有多个匹配时**
默认下 ，替换命令会替换该行第一个发现的pattern，在 s 命令后添加**数字**则只会替换指定位置的pattern.
使用 **g 参数** 会替换该行所有出现的pattern。
同时使用 **数字 和 g 参数** 会替换指定位置及以后的 pattern


=== 插入 ===
可插入多行，用 \  分隔

== 前行插入： i ==
nl /etc/passwd | sed -e '2i sfsdf' | head -n 10

== 行后面插入： a ==
nl /etc/passwd |sed -e '2a sfsdf'


==== 例子 ====


===== 高级 =====


===== pattern space =====

	sed 是 针对 **行** 的流编辑器，这是说：它每读一行就处理一行，之后再读取下一行。一般来说，读取的行会被存储在 pattern space 中，sed 命令就是对这个 pattern space 中的内容进行的。命令执行完毕后，pattern space 中的内容会被写出到 output stream，除非显式使用了 -n 参数。

	有些命令所引入的内容不会进入 pattern space。例如 r 命令读入的文件内容， a, i 命令添加的内容。他们会直接进入output stream。也就是说这些内容不会执行之后的命令操作。

	d 命令会删除当前 pattern space 中的内容，这样 d 之后的命令将没有操作对象，也就无法执行。因此 d 后面的命令是无效的。


===== 换行 =====

	当执行的命令语义未完全时，会自动执行下一行语句。

手动换行

在命令中 用 \ 表示未结束的行。下一行是本行的继续。
* 使用 \ 使排版更加易读
* 在较长的命令中间换行

	sed ' /WORD/ a\
	add this line after every line with WORD'

! 命令

	应用于一个命令或分组的命令集。进行反义操作。

区间

	3
	1,2
	2,$
	/regex/
	/regex/, /regex/
	2, /regex/
每个命令或命令组都可以设置一个有效区间。命令组内的子命令也可设置自己的区间


分组: { }
	分组命令通常用于为多个命令设置同一个区间(range)。

命令前的空格
	一般情况下，shell script 中行首空白会被忽略。但是跟在 ‘a', 'c', 'i' 命令后面的行首空白可能不会忽略，因sed版本而异。 





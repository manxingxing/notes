Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2012-05-12T15:07:49+08:00

====== 方法 ======
Created 星期六 12 五月 2012


==== 例子 ====

**不带参数的method**
'''
10.next
10.even?
'''

**带参数的method**
	''4.between?(1,5)''
**特殊方法：操作符**
	一般操作符
		+ , -
	带参数的操作符
		array[index]


===== 定义 =====
* **习惯约定**：表示查询的方法通常以__?__结尾；会修改接受者对象的方法，以__!__结尾；赋值方法以__=__结尾。(只是约定，不是说加个符号就行的)

	**def**	functionname(args)
		....
	**end**
* 可以有默认参数。参数在方法调用时求解
* 可选的数组参数(带*的参数)必须放在所有的数组参数的后面
* return语句将从该位置退出方法，并返回指定对象。


===== 参数 =====

==== 默认参数 ====

==== hash参数 ====
给hash参数赋值
* 也是普通参数
* 參數尾部的Hash参数可以省略**{ }** 符号。
* 当参数多于3个时，建议采用hash参数，这样可以使使用者无需记忆参数的顺序。

==== 可变个数参数---数组参数 ====
* **前面有*****号的数组形参可以接受数目不定的实参。并将其封装为一个数组。**
* 数组形参必须放置在**普通参数**后面, block参数的前面。
* 当使用数组参数时，该位置及其以后所有的参数都会当作这个数组参数的元素。如果没有参数，则是一个空数组。

**传递数组到 数组参数**
def test(*arr)
 arr
end

test(*[1,2,3])	# 参数 arr 的值就是 [1,2,3]

==== 代码块(block)参数 ====

1. block参数(在普通的参数名前放置一个__&__符号)必须放在参数列表的**最后一个**。无论何时调用该方法时，都会检查是否有关联的块。如果有，块将被转换成Proc类的对象，然后赋值给块参数。如果没有块，该参数将设置为nil。
   使用&block 参数时，内部用block.call() 方法调用代码块处理对象
2. 也可不设明显的block参数，在方法内部使用yield方法 将数据提交给代码块。在方法中使用： defined? yield 来判断是否传入了代码块参数。


===== 参数匹配 =====

* 基于位置的匹配。
* 使用Hash参数来模拟基于tag/name 的匹配


===== TODO: 定义操作符 =====
def +(a, b)
	# actions
end

==== Method对象和 UnboundMethod对象 ====

通过
Object.method(:name)
Object.public_method(:name)
方法来获取方法对应的Method对象。

=== Method对象 ===
和Proc一样，有.call方法，以及.arity等方法

=== Bind vs Unbind ===
method肯定是绑定在一个对象上的。可以用unbind方法，解除method对象和其宿主对象的绑定

method_obj.unbind

解除绑定后的method是一个UnboundMethod对象，可以使用bind方法，再次绑定到某个数组对象。

method_obj.bind(another_obj)

=== 转换成Proc ===

使用 & 操作符，可以把method对象，转换成proc，因此可以作为参数传递到另一个方法或迭代器。



